name: Tag and Deploy

inputs:
  service:
    description: 'Name of the service to deploy'
    required: true
    type: string
  image-tag:
    description: 'The Docker image tag to promote to stable'
    required: true
    type: string
  environment:
    description: 'Environment to deploy (staging or production)'
    required: true
    type: choice
    options: ['staging', 'production']
  skip-ecs-update:
    description: 'Build, tag and push the image, but skip updating the ECS services'
    required: false
    type: boolean
    default: false
  target:
    description: 'Deployment Target'
    required: false
    type: string
    default: 'main'
  skip-tagging-stable:
    description: 'Skip tagging previous image as stable'
    required: false
    type: boolean
    default: false
  role-ecs-update:
    description: 'Role for the infra update'
    required: false
    type: string
    default: 'skynet_infra_update'

runs:
  using: 'composite'
  steps:
    - name: Start Deploy Timer
      id: deploy-start
      run: echo "START_TIME=$(date +%s)" >> $GITHUB_OUTPUT
      shell: bash
    - uses: actions/checkout@v4

    # Get the partial arn for cluster name/services for the selected service
    - name: Load Service Configuration
      shell: bash
      id: config
      run: |
        SERVICE_FILE="${{ github.workspace }}/services.json"
        SELECTED_SERVICE="${{ inputs.service }}"

        if ! CONFIG=$(jq -c --arg service "$SELECTED_SERVICE" '.[$service]' "$SERVICE_FILE"); then
          echo "Error parsing $SERVICE_FILE or service $SELECTED_SERVICE not found."
          exit 1
        fi

        if [ "$CONFIG" == "null" ]; then
          echo "Service $SELECTED_SERVICE not found in $SERVICE_FILE"
          exit 1
        fi

        if [ -z "$(echo "$CONFIG" | jq -r '.repository // empty')" ]; then
          echo "Error: 'repository' field missing in service configuration."
          exit 1
        fi

        if [ -z "$(echo "$CONFIG" | jq -r '.cluster // empty')" ]; then
          echo "Error: 'cluster' field missing in service configuration."
          exit 1
        fi

        echo "Service '$SELECTED_SERVICE' is valid."
        echo "CONFIG=$CONFIG" >> $GITHUB_ENV

    # Configure credentials
    - uses: aws-actions/configure-aws-credentials@v3
      with:
        role-session-name: container_pusher
        role-to-assume: arn:aws:iam::986677156374:role/actions/build/container_pusher
        aws-region: us-east-1

    - name: Login to Amazon ECR
      id: ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Tag Image for Environment
      shell: bash
      run: |
        echo "::group::Pulling image"
        ECR_REGISTRY="${{ steps.ecr.outputs.registry }}"
        IMAGE_NAME="$ECR_REGISTRY/${{ fromJson(env.CONFIG).repository }}"
        IMAGE_TAG="${{ inputs.image-tag }}"
        ENVIRONMENT="${{ inputs.environment }}"
        TARGET="${{ inputs.target }}"
        SKIP_TAGGING_STABLE="${{ inputs.skip-tagging-stable }}"

        docker pull "$IMAGE_NAME:$IMAGE_TAG"
        echo "::endgroup::"

        tag_and_push() {
          local TAG_NAME=$1
          echo "Processing tag: $TAG_NAME"
          
          PREVIOUS_STABLE_TAG="${TAG_NAME}_stable"
          
          if [ "$SKIP_TAGGING_STABLE" = "true" ]; then
            echo "Skipping tagging previous image as stable"
          elif docker pull "$IMAGE_NAME:$TAG_NAME" 2>/dev/null; then
            echo "Previous image found, tagging as stable"
            docker tag "$IMAGE_NAME:$TAG_NAME" "$IMAGE_NAME:$PREVIOUS_STABLE_TAG"
            docker push "$IMAGE_NAME:$PREVIOUS_STABLE_TAG"
          else
            echo "No previous image for $TAG_NAME, skipping stable tagging"
          fi
          
          docker tag "$IMAGE_NAME:$IMAGE_TAG" "$IMAGE_NAME:$TAG_NAME"
          docker push "$IMAGE_NAME:$TAG_NAME"
          
          echo "PREVIOUS_STABLE_TAG_${TAG_NAME}=$PREVIOUS_STABLE_TAG" >> $GITHUB_ENV
        }

        echo "::group::Tagging and Pushing Images"
        case "$TARGET" in
          main)
            tag_and_push "$ENVIRONMENT"
            echo "TAG_NAME=$ENVIRONMENT" >> $GITHUB_ENV
            ;;
          blue)
            tag_and_push "blue_${ENVIRONMENT}"
            echo "TAG_NAME=blue_${ENVIRONMENT}" >> $GITHUB_ENV
            ;;
          green)
            tag_and_push "green_${ENVIRONMENT}"
            echo "TAG_NAME=green_${ENVIRONMENT}" >> $GITHUB_ENV
            ;;
          all)
            tag_and_push "$ENVIRONMENT"
            tag_and_push "blue_${ENVIRONMENT}"
            tag_and_push "green_${ENVIRONMENT}"
            echo "TAG_NAME=$ENVIRONMENT,blue_${ENVIRONMENT},green_${ENVIRONMENT}" >> $GITHUB_ENV
            ;;
          *)
            echo "Invalid target: $TARGET"
            exit 1
            ;;
        esac
        echo "::endgroup::"

    - uses: aws-actions/configure-aws-credentials@v3
      with:
        role-session-name: ${{ inputs.role-ecs-update }}
        role-to-assume: ${{ inputs.environment == 'staging' && format('arn:aws:iam::236194216641:role/{0}', inputs.role-ecs-update) || format('arn:aws:iam::981662312449:role/{0}', inputs.role-ecs-update) }}
        aws-region: us-east-1

    # This determines the full cluster ARN starting with the prefix since we use the same prefix in staging and prod
    - name: Find Cluster by Prefix
      shell: bash
      id: cluster
      run: |
        CLUSTER_ARN=$(aws ecs list-clusters \
          --query "clusterArns[?contains(@, '${{ fromJson(env.CONFIG).cluster }}')]" \
          --output text)

        if [ -z "$CLUSTER_ARN" ]; then
          echo "No cluster found matching prefix: ${{ fromJson(env.CONFIG).cluster }}"
          exit 1
        fi

        echo "Cluster found: $CLUSTER_ARN"
        echo "CLUSTER_ARN=$CLUSTER_ARN" >> $GITHUB_ENV

    # Updates each services with the new image
    - name: Deploy Services
      shell: bash
      run: |
        TARGET="${{ inputs.target }}"
        IFS=',' read -r -a SERVICES <<< "${{ join(fromJson(env.CONFIG).services, ',') }}"
        for SERVICE_PREFIX in "${SERVICES[@]}"; do
          SERVICE_ARN=$(aws ecs list-services \
            --cluster "$CLUSTER_ARN" \
            --query "serviceArns[?contains(@, '$SERVICE_PREFIX')]" \
            --output text)

          if [ -z "$SERVICE_ARN" ]; then
            echo "No service found for prefix: $SERVICE_PREFIX"
            exit 1
          fi

          SHOULD_DEPLOY=false
          case "$TARGET" in
            main)
              if [[ ! "$SERVICE_ARN" =~ [Bb]lue ]] && [[ ! "$SERVICE_ARN" =~ [Gg]reen ]]; then
                SHOULD_DEPLOY=true
              fi
              ;;
            blue)
              if [[ "$SERVICE_ARN" =~ [Bb]lue ]]; then
                SHOULD_DEPLOY=true
              fi
              ;;
            green)
              if [[ "$SERVICE_ARN" =~ [Gg]reen ]]; then
                SHOULD_DEPLOY=true
              fi
              ;;
            all)
              SHOULD_DEPLOY=true
              ;;
          esac

          if [ "$SHOULD_DEPLOY" = false ]; then
            echo "Skipping service (target=$TARGET): $SERVICE_ARN"
            continue
          fi

          echo "Service to update: $SERVICE_ARN"

          if [[ "${{ inputs.skip-ecs-update }}" != "true" ]]; then
            echo "::group::Updating service: $SERVICE_ARN"
            aws ecs update-service \
              --cluster "$CLUSTER_ARN" \
              --service "$SERVICE_ARN" \
              --force-new-deployment
            echo "::endgroup::"
          fi
        done

    - name: Wait for Services to Stabilize
      if: ${{ inputs.skip-ecs-update != 'true' }}
      id: stabilize
      shell: bash
      run: |
        set +e
        TARGET="${{ inputs.target }}"
        IFS=',' read -r -a SERVICES <<< "${{ join(fromJson(env.CONFIG).services, ',') }}"
        SERVICE_ARNS=()
        for SERVICE_PREFIX in "${SERVICES[@]}"; do
          SERVICE_ARN=$(aws ecs list-services \
            --cluster "$CLUSTER_ARN" \
            --query "serviceArns[?contains(@, '$SERVICE_PREFIX')]" \
            --output text)
          if [ -z "$SERVICE_ARN" ]; then
            echo "No service found for prefix: $SERVICE_PREFIX"
            exit 1
          fi
          
          SHOULD_WAIT=false
          case "$TARGET" in
            main)
              if [[ ! "$SERVICE_ARN" =~ [Bb]lue ]] && [[ ! "$SERVICE_ARN" =~ [Gg]reen ]]; then
                SHOULD_WAIT=true
              fi
              ;;
            blue)
              if [[ "$SERVICE_ARN" =~ [Bb]lue ]]; then
                SHOULD_WAIT=true
              fi
              ;;
            green)
              if [[ "$SERVICE_ARN" =~ [Gg]reen ]]; then
                SHOULD_WAIT=true
              fi
              ;;
            all)
              SHOULD_WAIT=true
              ;;
          esac

          if [ "$SHOULD_WAIT" = true ]; then
            SERVICE_ARNS+=($SERVICE_ARN)
          fi
        done

        echo "Waiting for service(s) to stabilize: ${SERVICE_ARNS[*]}"
        aws ecs wait services-stable \
          --cluster "$CLUSTER_ARN" \
          --services "${SERVICE_ARNS[@]}"

        WAIT_EXIT_CODE=$?
        echo "ROLLED_BACK=false" >> $GITHUB_OUTPUT

        if [ $WAIT_EXIT_CODE -ne 0 ]; then
          echo "Deployment failed to stabilize. Checking if tasks are crashing..."

          STOPPED_COUNT=0
          for ARN in "${SERVICE_ARNS[@]}"; do
            RECENT_FAILURES=$(aws ecs list-tasks \
              --cluster "$CLUSTER_ARN" \
              --service-name "$ARN" \
              --desired-status STOPPED \
              --max-items 10 \
              --query 'taskArns' \
              --output text)

            if [ -n "$RECENT_FAILURES" ]; then
              echo "Recent stopped tasks found for $ARN: $RECENT_FAILURES"
              STOPPED_COUNT=$((STOPPED_COUNT+1))
            fi
          done

          if [ $STOPPED_COUNT -gt 0 ]; then
            echo "Services are failing. Rolling back to previous stable images"
            echo "ROLLED_BACK=true" >> $GITHUB_OUTPUT

            ECR_REGISTRY="${{ steps.ecr.outputs.registry }}"
            IMAGE_NAME="$ECR_REGISTRY/${{ fromJson(env.CONFIG).repository }}"
            ENVIRONMENT="${{ inputs.environment }}"

            rollback_tag() {
              local TAG_NAME=$1
              local STABLE_TAG="${TAG_NAME}_stable"
              
              if docker pull "$IMAGE_NAME:$STABLE_TAG" 2>/dev/null; then
                echo "Rolling back $TAG_NAME to $STABLE_TAG"
                docker tag "$IMAGE_NAME:$STABLE_TAG" "$IMAGE_NAME:$TAG_NAME"
                docker push "$IMAGE_NAME:$TAG_NAME"
              else
                echo "No stable image found for $TAG_NAME"
              fi
            }

            case "$TARGET" in
              main)
                rollback_tag "$ENVIRONMENT"
                ;;
              blue)
                rollback_tag "blue_${ENVIRONMENT}"
                ;;
              green)
                rollback_tag "green_${ENVIRONMENT}"
                ;;
              all)
                rollback_tag "$ENVIRONMENT"
                rollback_tag "blue_${ENVIRONMENT}"
                rollback_tag "green_${ENVIRONMENT}"
                ;;
            esac

            for ARN in "${SERVICE_ARNS[@]}"; do
              echo "Rolling back service: $ARN"
              aws ecs update-service \
                --cluster "$CLUSTER_ARN" \
                --service "$ARN" \
                --force-new-deployment
            done
          fi

          exit 1
        else
          echo "Services stabilized successfully."
        fi

    - name: Deploy Summary
      if: always()
      id: deploy-timing
      run: |
        END_TIME=$(date +%s)
        DURATION=$((END_TIME - ${{ steps.deploy-start.outputs.START_TIME }}))
        ROLLED_BACK="${{ steps.stabilize.outputs.ROLLED_BACK || 'false' }}"
        DEPLOY_STATUS="${{ steps.stabilize.outcome }}"

        format_duration() {
          local total_seconds=$1
          local minutes=$((total_seconds / 60))
          local seconds=$((total_seconds % 60))
          if [ $minutes -gt 0 ]; then
            echo "${minutes}m ${seconds}s"
          else
            echo "${seconds}s"
          fi
        }

        DEPLOY_FORMATTED=$(format_duration $DURATION)

        if [ "$DEPLOY_STATUS" = "success" ]; then
          STATUS_ICON="✅"
        else
          STATUS_ICON="❌"
        fi

        echo "**Deploy:** ${DEPLOY_FORMATTED} ${STATUS_ICON}" >> $GITHUB_STEP_SUMMARY

        if [ "$ROLLED_BACK" = "true" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "⚠️ **Rolled back** - tasks were crashing, check service logs" >> $GITHUB_STEP_SUMMARY
        fi
      shell: bash
